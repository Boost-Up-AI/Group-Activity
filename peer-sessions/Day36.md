# Day36 피어세션 정리


1. 지호님의 리트코드 문제 추천

   * <207. Course Schedule>, version2 도 추천
   * 백준은 문제를 해결하기 위한 아이디어가 상당히 겹치는데, (예를 들면 구슬탈출 1~4. 값의 범위가 바뀌어서 살짝씩 문제를 트는 정도) 리트 코드는 비슷해 보이는 문제를 완전히 다르게 풀어야 하는 경우가 많다. 색다른 문제가 많으니 PS를 위해서 리트코드도 적극 활용해볼 것! (공간, 시간복잡도 비교해가면서)
     

2. 정렬 알고리즘

   * 참고 사이트들
     * https://www.fun-coding.org/Chapter12-bubblesorting.html
     * https://d2.naver.com/helloworld/0315536

   * (main) quick 소트, merge sort 시간 복잡도 및 정렬 과정 알아야. 둘다 평균 O(nlogn) 시간복잡도. 트리를 연상하자
   * 퀵 소트 핵심 : pivot
     * 퀵소트 - pivot을 무엇으로 설정하는가?가 중요한 이슈. 가장 오른쪽에 있는 원소를 기준으로 한다고 예를 들면,  그 피벗을 기준으로 left, right를 나누며 pivot의 상대적 위치 만큼은 확정되게 된다. 이 과정을 반복. 
     * 피벗을 어떻게 잡느냐에 따라서 퀵 소트 성능이 달라짐. 만약, 내림차순으로 데이터가 정렬되어 있는데 맨 오른쪽에 있는 원소를 피벗으로 하면 성능 최악. (O(N^2))
     * 버블 소트보다(primitive) 삽입 정렬이 더 좋은 성능. 정렬된 데이터라면 한 원소씩 선형 탐색하고 끝나게 되므로
   * merge sort는 성능이 최선-평균-최악 모두 O(nlogn). 성능이 고르다. 
     

3. 값의 범위가 어마 어마 할때 떠올리는 접근법?

   (지호님)

   백준이나 삼성 사이트는 시간이나 메모리 제한 나와있다. 그렇지 않은 경우에도 문제의 조건의 범위를 보고,  10만, 100만 넘어간다라고 하면 O(N^2)알고리즘은 무조건 버린다. 무조건 이분탐색이나 퀵 소트부터 떠올린다. 

   브루트포스와 같은 모든 경우의 수를 봐야하는 문제가 아니면, 모든 탐색이나 정렬 문제들은 logn, nlogn쓰는걸로 연산을 해놔야 한다. 아니면 터진다. bomb
   

4. 주로 사용하는 자료구조

   1. 배열
   2. 큐랑 스택
   3. 딕셔너리와 세트
      

5. 힙 자료구조 공부 

   * https://www.daleseo.com/python-heapq/

   - 프로그래머스 - ''디스크 컨트롤러'' 문제 추천

